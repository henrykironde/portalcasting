% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/process_casts.R
\name{process forecast output}
\alias{process forecast output}
\alias{process_model_output}
\alias{read_forecast_table}
\alias{read_forecast_tables}
\alias{add_observations_to_forecast_table}
\alias{read_forecast_metadata}
\alias{read_model_fit}
\alias{read_model_forecast}
\alias{select_forecasts}
\alias{read_forecasts_metadata}
\title{Process and Save Forecast Output to Files}
\usage{
process_model_output(
  main = ".",
  model_fit = NULL,
  model_forecast,
  model,
  dataset,
  species
)

read_forecast_table(main = ".", forecast_id = NULL)

read_forecast_tables(main = ".", forecast_ids = NULL)

add_observations_to_forecast_table(main = ".", forecast_table = NULL)

read_forecast_metadata(main = ".", forecast_id = NULL)

read_model_fit(main = ".", forecast_id = NULL)

read_model_forecast(main = ".", forecast_id = NULL)

select_forecasts(
  main = ".",
  forecast_ids = NULL,
  forecast_groups = NULL,
  models = NULL,
  datasets = NULL,
  species = NULL,
  historic_end_newmoonnumbers = NULL
)

read_forecasts_metadata(main = ".")
}
\arguments{
\item{main}{\code{character} value of the name of the main component of the directory tree.}

\item{model_fit, model_forecast}{Output from a model's fit and forecast functions.}

\item{model, models}{\code{character} values of the name(s) of the model(s) of interest, as indexed within the directory in the \code{forecasts} sub folder. See the forecasts metadata file (\code{forecasts_metadata.csv}) for summary information. If \code{NULL} (the default), the most recently generated forecast's output is read in. \cr
\code{models} can be NULL, one value, or more than one values, \code{model} can only be NULL or one value.}

\item{dataset, datasets}{\code{character} vector of the rodent dataset name(s) to include.
\code{datasets} can be NULL, one value, or more than one values, \code{dataset} can only be NULL or one value.}

\item{species}{\code{character} value of the species codes (or \code{"total"} for the total across species) to include. Default value is \code{NULL}, which equates to no selection with respect to \code{species}.}

\item{forecast_id, forecast_ids}{\code{integer} (or integer \code{numeric}) value(s) representing the forecast(s) of interest, as indexed within the directory in the \code{casts} sub folder. See the forecasts metadata file (\code{forecasts_metadata.csv}) for summary information. If \code{NULL} (the default), the most recently generated forecast's output is read in. \cr
\code{forecast_ids} can be NULL, one value, or more than one values, \code{forecast_id} can only be NULL or one value.}

\item{forecast_table}{A \code{data.frame} of a cast's output. See \code{\link{read_forecast_table}}.}

\item{forecast_groups}{\code{integer} (or integer \code{numeric}) value of the forecast groups to include. Default value is \code{NULL}, which equates to no selection with respect to \code{forecast_group}.}

\item{historic_end_newmoonnumbers}{\code{integer} (or integer \code{numeric}) newmoon numbers of the forecast origin. Default value is \code{NULL}, which equates to no selection.}
}
\value{
\code{process_model_output}: relevant elements are saved to external files, and returned as a \code{list}. \cr
\code{read_forecast_table}: forecast table \code{data.frame}. \cr
\code{read_forecast_tables}: \code{data.frame} of combined forecast tables. \cr
\code{add_observations_to_forecast_table}: forecast table \code{data.frame} with an observation column added. \cr
\code{read_forecast_metadata}: \code{list} of \code{forecast_metadata}. \cr
\code{read_model_fit}: forecast output (typically as a \code{list}). \cr
\code{read_model_forecast}: forecast output (typically as a \code{list}). \cr
\code{select_forecasts}:  \code{data.frame} of selected forecasts' metadata. \cr
\code{read_forecasts_metadata}: \code{data.frame} of forecasts' metadata.
}
\description{
Take the model fit and forecast output, process them into savable objects, and save them to the output folders. \cr
The forecast metadata file is updated accordingly to track the saved output. \cr
\code{add_observations_to_forecast_table} appends a column of observations to a forecast's forecast tab. If a model interpolated a data set, it adds the true (non-interpolated) observations so that model predictions are all compared to the same data. \cr
\code{select_forecasts} determines the forecasts that match user specifications. Functionally, it is a wrapper on \code{\link{read_forecasts_metadata}} with filtering for specifications that provides a simple user interface to the large set of available forecasts via the metadata.
}
\details{
Four model-specific output components are saved and returned:
* \code{forecast_metadata}: saved out with \code{\link[yaml:write_yaml]{write_yaml}}.
* \code{forecast_tab}: saved using \code{\link{write_csv_arrow}}.
* \code{model_fit}: saved out as a serialized \code{JSON} file via \code{\link[jsonlite:serializeJSON]{serializeJSON}} and \code{\link[jsonlite:read_json]{read_json}}, so quite flexible with respect to specific object structure.
* \code{model_forecast}: saved out as a serialized \code{JSON} file via \code{\link[jsonlite:serializeJSON]{serializeJSON}} and \code{\link[jsonlite:read_json]{read_json}}, so quite flexible with respect to specific object structure.
}
\examples{
\dontrun{
   main1 <- file.path(tempdir(), "forecast_output")

   setup_dir(main = main1)
   dataset <- "all"
   species <- "DM"
   model   <- "AutoArima"
 
   abundance      <- prepare_abundance(main    = main1,
                                       dataset = dataset,
                                       species = species,
                                       model   = model)
   model_controls <- models_controls(main       = main1,
                                     models     = model)[[model]]
   metadata       <- read_metadata(main        = main1)
   newmoons       <- read_newmoons(main        = main1)                                        
   covariates     <- read_covariates(main      = main1)
 
   fit_args  <- named_null_list(element_names = names(model_controls$fit$args))
   for (i in 1:length(fit_args)) {
     fit_args[[i]] <- eval(parse(text = model_controls$fit$args[i]))
   }
   model_fit  <- do.call(what = model_controls$fit$fun,
                         args = fit_args)
 
 
   forecast_args  <- named_null_list(element_names = names(model_controls$cast$args))
   for (i in 1:length(forecast_args)) {
     forecast_args[[i]] <- eval(parse(text = model_controls$cast$args[i]))
   }
 
   model_forecast <- do.call(what = model_controls$cast$fun,
                         args = forecast_args)
 
   process_model_output(main           = main1,
                        model_fit      = model_fit,
                        model_forecast = model_forecast,
                        model          = model,
                        dataset        = dataset,
                        species        = species) 

   cast_table     <- read_forecast_table(main = main1)
   cast_table2    <- add_observations_to_forecast_table(main = main1,
                                                        forecast_table = cast_table)
   cast_tables    <- read_forecast_tables(main = main1)
   cast_metadata  <- read_forecast_metadata(main = main1)
   cast_fit       <- read_model_fit(main = main1)
   cast_forecast  <- read_model_forecast(main = main1)

   casts_metadata <- read_forecasts_metadata(main = main1)
   select_forecasts(main = main)

   unlink(main1, recursive = TRUE)
}

}
