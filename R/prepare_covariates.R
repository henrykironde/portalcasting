#' @title Prepare Covariate Data for Casting
#'
#' @description Prepare and combine the historical and cast covariate data for a model run. \cr \cr 
#'              \code{prepare_historical_covariates} and \code{prepare_forecast_covariates} ready the historical and -casted covariates, respectively. \cr \cr
#'              \code{prepare_covariates} combines \code{prepare_historical_covariates} and \code{prepare_forecast_covariates}.
#'
#' @param main \code{character} value of the name of the main component of the directory tree.
#'
#' @param settings \code{list} of controls for the directory, with defaults set in \code{\link{directory_settings}} that should generally not need to be altered.
#'
#' @param origin \code{Date} for the forecast origin. Defaults to today's date.
#'
#' @param quiet \code{logical} indicator if progress messages should be quieted.
#'
#' @param verbose \code{logical} indicator if detailed messages should be printed.
#'
#' @return \code{data.frame} of historical and/or -casted covariates that is also saved out to \code{settings$files$covariates} if indicated by \code{settings$save}.
#'  
#' @details \code{prepare_historical_covariates} creates a \code{data.frame} of historical weather (\code{\link[portalr]{weather}}) and NDVI data (\code{\link[portalr]{ndvi}}). Automatically goes all the way back to the beginning of the available data, as the table is trimmed later as needed. NDVI data are generated by \code{\link[portalr]{ndvi}}. \cr \cr
#'          \code{prepare_forecast_covariates} combines the NMME climate forecasts (\code{\link{download_climate_forecasts}}) with NDVI forecasts using a seasonal auto-ARIMA model on the most resolved and resources data available via (\code{\link[portalr]{ndvi}}). 
#'  
#' @name prepare covariates
#'
#' @export
#'
xprepare_covariates <- function (main     = ".", 
                                settings = directory_settings(), 
                                origin   = Sys.Date(), 
                                quiet    = FALSE, 
                                verbose  = FALSE) {


  messageq("  - covariate data files", quiet = quiet)

  historic_covariates <- prepare_historic_covariates(main     = main, 
                                                     settings = settings, 
                                                     quiet    = quiet, 
                                                     verbose  = verbose)
  forecast_covariates <- prepare_forecast_covariates(main     = main,
                                                     origin   = origin, 
                                                     settings = settings, 
                                                     quiet    = quiet, 
                                                     verbose  = verbose)

  # patch to deal with split of the newmoon
  # this is when there are data for a newmoon in both historic and forecast tables (when we're in the middle of a newmoon)

  if (any(forecast_covariates$newmoonnumber %in% historic_covariates$newmoonnumber)) {

    forecast_covariates <- forecast_covariates[!(forecast_covariates$newmoonnumber %in% historic_covariates$newmoonnumber), ]

  }

  # end patch

  write_data(x         = rbind(historic_covariates, forecast_covariates), 
             main      = main, 
             save      = settings$save, 
             filename  = settings$files$covariates, 
             quiet     = !verbose)

}


#' @rdname prepare-covariates
#'
#' @export
#'
prepare_covariates <- function (main             = ".", 
                                timeseries_start = as.Date("1995-01-01"), 
                                origin           = Sys.Date(),
                                lead_time        = 365,
                                max_lag          = 365,
                                lag_buffer       = 30,
                                settings         = directory_settings(), 
                                quiet            = FALSE, 
                                verbose          = FALSE) {

# need to shift this to level daily so we can manage when a newmoon is split between historic and forecast days
# but what about when we only want historic and not forecast? or vice-versa... do we mark it somehow?

  weather_data <- weather(level   = "daily", 
                          horizon = 1, 
                          path    = file.path(main, settings$subdirectories$resources))
  ndvi_data    <- ndvi(level      = "daily", 
                       path       = file.path(main, settings$subdirectories$resources))

  climate_forecasts <- read_climate_forecasts(main     = main,
                                              settings = settings)
  newmoons          <- read_newmoons(main     = main,
                                     settings = settings)
  control_rodents   <- read_rodents_table(main     = main,
                                          dataset  = "controls", 
                                          settings = settings) 

  # have the lag go back a lunar month further to facilitate half month inclusions etc
  timeseries_start_lagged <- timeseries_start - max_lag - lag_buffer
  forecast_start           <- origin + 1
  forecast_end             <- origin + lead_time

  historic_weather         <- data.frame(date = seq(timeseries_start_lagged, origin, 1))

  weather_rows                   <- match(historic_weather$date, weather_data$date)
  historic_weather$mintemp       <- weather_data$mintemp[weather_rows]
  historic_weather$maxtemp       <- weather_data$maxtemp[weather_rows]
  historic_weather$meantemp      <- weather_data$meantemp[weather_rows]
  historic_weather$precipitation <- weather_data$precipitation[weather_rows]
  historic_weather$source        <- "historic"             

  forecast_weather               <- data.frame(date = seq(forecast_start, forecast_end, 1))

  forecast_weather_rows          <- match(forecast_weather$date, climate_forecasts$date)
  forecast_weather$mintemp       <- climate_forecasts$mintemp[forecast_weather_rows]
  forecast_weather$maxtemp       <- climate_forecasts$maxtemp[forecast_weather_rows]
  forecast_weather$meantemp      <- climate_forecasts$meantemp[forecast_weather_rows]
  forecast_weather$precipitation <- climate_forecasts$precipitation[forecast_weather_rows]
  dayin                          <- forecast_weather$date %in% climate_forecasts$date
  forecast_weather$source[dayin] <- "nmme_forecast"

  weather_together <- rbind(historic_weather, forecast_weather)

  # fill in the missing values in the time series with a seasonal auto arima model
  # this accounts for needing a climate forecast a year out now, whereas we did not before
  # the models we get don't always go out that far, so we extend with a seasonal autoarima on each covariate

  in_fit         <- !is.na(weather_together$source)
  date_fit       <- weather_together$date[in_fit]
  foy_fit        <- foy(date_fit)
  cos_fit        <- cos(2 * pi * foy_fit)
  sin_fit        <- sin(2 * pi * foy_fit)
  xreg_fit       <- data.frame(cos_seas = cos_fit, sin_seas = sin_fit)
  xreg_fit       <- as.matrix(xreg_fit)

  mintemp_model  <- auto.arima(weather_together$mintemp[in_fit], xreg = xreg_fit)
  maxtemp_model  <- auto.arima(weather_together$maxtemp[in_fit], xreg = xreg_fit)
  meantemp_model <- auto.arima(weather_together$meantemp[in_fit], xreg = xreg_fit)
  precip_model   <- auto.arima(weather_together$precipitation[in_fit], xreg = xreg_fit)

  in_cast        <- is.na(weather_together$source)
  date_cast      <- weather_together$date[in_cast]
  foy_cast       <- foy(date_cast)
  cos_cast       <- cos(2 * pi * foy_cast)
  sin_cast       <- sin(2 * pi * foy_cast)
  xreg_cast      <- data.frame(cos_seas = cos_cast, sin_seas = sin_cast)
  xreg_cast      <- as.matrix(xreg_cast)

  mintemp_forecast  <- forecast(mintemp_model, xreg = xreg_cast)$mean
  maxtemp_forecast  <- forecast(maxtemp_model, xreg = xreg_cast)$mean
  meantemp_forecast <- forecast(meantemp_model, xreg = xreg_cast)$mean
  precip_forecast   <- pmax(0, forecast(precip_model, xreg = xreg_cast)$mean)
 
  weather_together$mintemp[in_cast]       <- mintemp_forecast
  weather_together$maxtemp[in_cast]       <- maxtemp_forecast
  weather_together$meantemp[in_cast]      <- meantemp_forecast
  weather_together$precipitation[in_cast] <- precip_forecast
  weather_together$source[in_cast]        <- "seasonal_autoarima_forecast"


  control_rodents$censusdate   <- as.Date(newmoons$censusdate[match(control_rodents$newmoonnumber, newmoons$newmoonnumber)])
  control_rodents$newmoondate  <- as.Date(newmoons$newmoondate[match(control_rodents$newmoonnumber, newmoons$newmoonnumber)]) 
  control_rodents$date         <- control_rodents$censusdate
  control_rodents$source       <- "historic"
  nadate                       <- is.na(control_rodents$date)
  control_rodents$date[nadate] <- control_rodents$newmoondate[nadate]

  historic_ordii               <- control_rodents[ , c("newmoonnumber", "DO", "date", "source")]
  moonin                       <- newmoons$newmoondate > origin
  forecast_ordii               <- data.frame(newmoonnumber = newmoons$newmoonnumber[moonin], 
                                             DO            = NA,
                                             date          = newmoons$newmoondate[moonin],
                                             source        = "psGARCH_forecast")
  

  past                         <- list(past_obs = 1, past_mean = 13)
  ordii_model                  <- tsglm(historic_ordii$DO, model = past, distr = "poisson", link = "log")
  forecast_ordii$DO            <- predict(ordii_model, n.ahead = nrow(forecast_ordii))$pred
  ordii_together               <- rbind(historic_ordii, forecast_ordii)
  

# ndvi is a bit of a challenge because we have multiple sources now
# and so can end up with multiple readings on the same day

  ndvi_data$date        <- as.Date(ndvi_data$date)
  possible_sensors      <- levels(as.factor(ndvi_data$sensor))
  npossible_sensors     <- length(possible_sensors)

  ndvi_models           <- named_null_list(possible_sensors)
  ndvi_forecasts        <- named_null_list(possible_sensors)
  ndvi_dates            <- named_null_list(possible_sensors)
  for (i in 1:npossible_sensors) {
    sensor_data         <- ndvi_data[ndvi_data$sensor == possible_sensors[i], ]
    possible_dates_fit      <- seq(min(ndvi_data$date), max(sensor_data$date), 1)
    sensor_observations <- sensor_data$ndvi[match(possible_dates_fit, sensor_data$date)]

    foy_fit        <- foy(possible_dates_fit)
    cos_fit        <- cos(2 * pi * foy_fit)
    sin_fit        <- sin(2 * pi * foy_fit)
    xreg_fit       <- data.frame(cos_seas = cos_fit, sin_seas = sin_fit)
    xreg_fit       <- as.matrix(xreg_fit)

    ndvi_models[[i]]    <- auto.arima(sensor_observations, xreg = xreg_fit)

    possible_dates_cast      <- seq(max(sensor_data$date), max(ndvi_data$date), 1)
    ndays_cast      <- length(possible_dates_cast)
    foy_cast        <- foy(possible_dates_cast)
    cos_cast        <- cos(2 * pi * foy_cast)
    sin_cast        <- sin(2 * pi * foy_cast)
    xreg_cast       <- data.frame(cos_seas = cos_cast, sin_seas = sin_cast)
    xreg_cast       <- as.matrix(xreg_cast)   
    ndvi_forecasts[[i]] <- forecast(ndvi_models[[i]], ndays_cast, xreg = xreg_cast)
    
    ndvi_dates[[i]] <- list(dates_fit  = possible_dates_fit,
                            dates_cast = possible_dates_cast)
  }

forecast:::forecast.Arima



}

#' @rdname prepare-covariates
#'
#' @export
#'
prepare_forecast_covariates <- function (main      = ".", 
                                         origin    = Sys.Date(), 
                                         settings  = directory_settings(), 
                                         quiet     = TRUE,
                                         verbose   = FALSE) {

  if (origin == Sys.Date()) {

    newmoons <- read_newmoons(main     = main,
                              settings = settings)

    climate_forecasts <- read_climate_forecasts(main     = main,
                                                settings = settings)

    if (max(climate_forecasts$date) < (as.Date(max(newmoons$newmoondate)) + 27)) {

      # this accounts for needing a climate forecast a year out now, whereas we did not before
      # the models we get don't always go out that far.

      to_cast <- seq.Date(as.Date(max(climate_forecasts$date) + 1), as.Date(max(newmoons$newmoondate)) + 27, 1)
      
      date_fit     <- climate_forecasts$date
      jday_fit     <- as.numeric(format(date_fit, "%j"))
      yr_fit       <- format(date_fit, "%Y")
      nye_fit      <- as.Date(paste(yr_fit, "-12-31", sep = ""))
      nye_jday_fit <- as.numeric(format(nye_fit, "%j"))
      fr_of_yr_fit <- jday_fit/nye_jday_fit
      cos_fit      <- cos(2 * pi * fr_of_yr_fit)
      sin_fit      <- sin(2 * pi * fr_of_yr_fit)
      xreg_fit     <- data.frame(cos_seas = cos_fit, sin_seas = sin_fit)
      xreg_fit     <- as.matrix(xreg_fit)

      mintemp_model   <- auto.arima(climate_forecasts$mintemp, xreg = xreg_fit)
      maxtemp_model   <- auto.arima(climate_forecasts$maxtemp, xreg = xreg_fit)
      meantemp_model  <- auto.arima(climate_forecasts$meantemp, xreg = xreg_fit)
      precip_model    <- auto.arima(climate_forecasts$precipitation, xreg = xreg_fit)

      date_fcast     <- to_cast
      jday_fcast     <- as.numeric(format(date_fcast, "%j"))
      yr_fcast       <- format(date_fcast, "%Y")
      nye_fcast      <- as.Date(paste(yr_fcast, "-12-31", sep = ""))
      nye_jday_fcast <- as.numeric(format(nye_fcast, "%j"))
      fr_of_yr_fcast <- jday_fcast/nye_jday_fcast
      cos_fcast      <- cos(2 * pi * fr_of_yr_fcast)
      sin_fcast      <- sin(2 * pi * fr_of_yr_fcast)
      xreg_fcast     <- data.frame(cos_seas = cos_fcast, sin_seas = sin_fcast)
      xreg_fcast     <- as.matrix(xreg_fcast)

      mintemp_forecast  <- forecast(mintemp_model, xreg = xreg_fcast)$mean
      maxtemp_forecast  <- forecast(maxtemp_model, xreg = xreg_fcast)$mean
      meantemp_forecast <- forecast(meantemp_model, xreg = xreg_fcast)$mean
      precip_forecast   <- pmax(0, forecast(precip_model, xreg = xreg_fcast)$mean)

      casts <- data.frame(date = date_fcast, 
                          mintemp = mintemp_forecast, 
                          maxtemp = maxtemp_forecast, 
                          meantemp = meantemp_forecast, 
                          precipitation = precip_forecast)

      climate_forecasts <- rbind(climate_forecasts, casts)


    }


    ndvi_data      <- ndvi(level = "daily", path = file.path(main, settings$subdirectories$resources))
    ndvi_data$date <- as.Date(ndvi_data$date)
 
    date_fit     <- ndvi_data$date
    jday_fit     <- as.numeric(format(date_fit, "%j"))
    yr_fit       <- format(date_fit, "%Y")
    nye_fit      <- as.Date(paste(yr_fit, "-12-31", sep = ""))
    nye_jday_fit <- as.numeric(format(nye_fit, "%j"))
    fr_of_yr_fit <- jday_fit/nye_jday_fit
    cos_fit      <- cos(2 * pi * fr_of_yr_fit)
    sin_fit      <- sin(2 * pi * fr_of_yr_fit)
    xreg_fit     <- data.frame(cos_seas = cos_fit, sin_seas = sin_fit)
    xreg_fit     <- as.matrix(xreg_fit)

    ndvi_model   <- auto.arima(ndvi_data$ndvi, xreg = xreg_fit)

    date_fcast     <- climate_forecasts$date
    jday_fcast     <- as.numeric(format(date_fcast, "%j"))
    yr_fcast       <- format(date_fcast, "%Y")
    nye_fcast      <- as.Date(paste(yr_fcast, "-12-31", sep = ""))
    nye_jday_fcast <- as.numeric(format(nye_fcast, "%j"))
    fr_of_yr_fcast <- jday_fcast/nye_jday_fcast
    cos_fcast      <- cos(2 * pi * fr_of_yr_fcast)
    sin_fcast      <- sin(2 * pi * fr_of_yr_fcast)
    xreg_fcast     <- data.frame(cos_seas = cos_fcast, sin_seas = sin_fcast)
    xreg_fcast     <- as.matrix(xreg_fcast)

    ndvi_forecast <- forecast(ndvi_model, xreg = xreg_fcast)

    climate_forecasts$ndvi <- as.numeric(ndvi_forecast$mean)


  } else {

    # removed for the time being
    stop(" retrieval of pre-existing covariate data not presently available!")

  }

  warm_precip <- climate_forecasts$precipitation * as.numeric(climate_forecasts$mintemp >= 4)

  climate_forecasts$warm_precip <- warm_precip



  moons <- read_newmoons(main = main, settings = settings)

  climate_forecasts <- add_newmoonnumbers_from_dates(climate_forecasts, moons)
  
# not sure why this is called "hist_time" ... that's confusing, probably an outdated naming
  hist_time_obs <- climate_forecasts$newmoonnumber
  min_hist_time <- min(hist_time_obs)
  max_hist_time <- max(hist_time_obs)
  hist_time     <- min_hist_time:max_hist_time
  nhist_time    <- length(hist_time)

  mintemps       <- rep(NA, nhist_time)
  maxtemps       <- rep(NA, nhist_time)
  meantemps      <- rep(NA, nhist_time)
  precipitations <- rep(NA, nhist_time)
  warm_precips   <- rep(NA, nhist_time)
  ndvis          <- rep(NA, nhist_time)

  for (i in 1:nhist_time) {

    days_in           <- climate_forecasts$newmoonnumber == hist_time[i]
    mintemps[i]       <- min(climate_forecasts$mintemp[days_in], na.rm = TRUE)
    maxtemps[i]       <- max(climate_forecasts$maxtemp[days_in], na.rm = TRUE)
    meantemps[i]      <- mean(climate_forecasts$meantemp[days_in], na.rm = TRUE)
    precipitations[i] <- sum(climate_forecasts$precipitation[days_in], na.rm = TRUE)
    warm_precips[i]   <- sum(climate_forecasts$warm_precip[days_in], na.rm = TRUE)
    ndvis[i]          <- mean(climate_forecasts$ndvi[days_in], na.rm = TRUE)
  
  }

# make sure this is all aligning right with the lags and forecasts of covariates
  historical_covariates <- read_historical_covariates(main = main,
                                                      settings = settings)

head(historical_covariates)


  ndvi_13_moon        <- filter(c(historical_covariates$ndvi, ndvis), rep(1, 13), sides = 1)
  warm_precip_3_moon  <- filter(c(historical_covariates$warm_precip, warm_precips), rep(1, 3), sides = 1)


  mintemp_6_moon        <- as.numeric(filter(historical_covariates$mintemp, rep(1, 6), sides = 1))
  meantemp_6_moon       <- as.numeric(filter(historical_covariates$meantemp, rep(1, 6), sides = 1))
  maxtemp_6_moon        <- as.numeric(filter(historical_covariates$maxtemp, rep(1, 6), sides = 1))
  precipitation_6_moon  <- as.numeric(filter(historical_covariates$precipitation, rep(1, 6), sides = 1))
  ndvi_6_moon           <- as.numeric(filter(historical_covariates$ndvi, rep(1, 6), sides = 1))

  past <- list(past_obs = 1, past_mean = 13)
  ordii_controls_mod  <- tsglm(historical_covariates$ordii_controls, model = past, distr = "poisson", link = "log")

  ordii_controls_cast <- predict(ordii_controls_mod, nhist_time)$pred

  moon_foys        <- foy(dates = moons$newmoondate[match(hist_time, moons$newmoonnumber)])
  sin2pifoy    <- sin(2 * pi * moon_foys)
  cos2pifoy    <- cos(2 * pi * moon_foys)
  
  hist_climate_forecasts <- data.frame(newmoonnumber       = hist_time, 
                                       date                = moons$newmoondate[match(hist_time, moons$newmoonnumber)],
                                       mintemp             = mintemps,
                                       maxtemp             = maxtemps,
                                       meantemp            = meantemps,
                                       precipitation       = precipitations,
                                       warm_precip         = warm_precips,
                                       ndvi                = ndvis,
                                       warm_precip_3_moon  = warm_precip_3_moon[(length(warm_precip_3_moon) - nhist_time + 1):length(warm_precip_3_moon)], 
                                       ndvi_13_moon        = ndvi_13_moon[(length(ndvi_13_moon) - nhist_time + 1):length(ndvi_13_moon)], 
                                       ordii_controls      = ordii_controls_cast,
                                       sin2pifoy           = sin2pifoy,
                                       cos2pifoy           = cos2pifoy,
                                       source              = "forecast")


  cols_to_keep <- c("newmoonnumber", "date", "mintemp", "maxtemp", "meantemp", "precipitation", "warm_precip", "ndvi", 
                    "mintemp_6_moon", "meantemp_6_moon", "maxtemp_6_moon", "precipitation_6_moon", "ndvi_6_moon", 
                    "warm_precip_3_moon", "ndvi_13_moon", "ordii_controls", "sin2pifoy", "cos2pifoy", "source")


  write_data(x         = hist_climate_forecasts, 
             main      = main, 
             save      = settings$save, 
             filename  = settings$files$forecast_covariates, 
             quiet     = !verbose)

}

#' @title Lag covariate data
#'
#' @description Lag the covariate data together based on the new moons
#'
#' @param covariates \code{data.frame} of covariate data to be lagged. 
#'  
#' @param lag \code{integer} lag between rodent census and covariate data, in new moons.
#'  
#' @param tail \code{logical} indicator if the data lagged to the tail end should be retained.
#'
#' @return \code{data.frame} with a \code{newmoonnumber} column reflecting the lag.
#'
#' @export
#'
lag_covariates <- function (covariates, 
                            lag, 
                            tail = FALSE){

  covariates$moon_lag <- covariates$newmoonnumber + lag
  
  if (tail == FALSE) {

    oldest_included_moon     <- covariates$newmoonnumber[1]
    most_recent_moon         <- covariates$newmoonnumber[nrow(covariates)]
    hist_moons               <- oldest_included_moon:most_recent_moon
    moon_match               <- match(covariates$moon_lag, hist_moons)
    covariates$newmoonnumber <- hist_moons[moon_match]
    if (lag > 0) {
      covariates <- covariates[-(1:lag), ]
    }

  }

  covariates$newmoonnumber <- covariates$moon_lag
  covariates$moon_lag      <- NULL
  covariates

}

